<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>异步 | brealinblog</title><meta name=keywords content="C#"><meta name=description content="查阅 MSDN 异步编程以了解更多
异步编程 在 C# 中，异步编程是一种编程范式，它允许程序异步执行任务，而不会阻塞主线程或其他任务的执行。在异步程序中，程序可以继续执行其他任务，而无需等待一个任务完成
优势 异步编程可以为需要执行 I/O 操作或其他耗时任务的应用程序提供显著的优势，例如访问数据库、下载文件或执行网络通信。通过使用异步编程，应用程序可以提高性能、响应性、可扩展性和资源效率，同时简化代码并提高容错性
误解 异步编程总是更快：虽然异步编程可以提高性能，但它并不能保证在所有情况下都能提供更快的执行速度，如果一个应用程序没有大量的 I/O 操作或耗时任务，使用异步编程可能不会提供任何性能优势，甚至可能引入不必要的复杂性
异步编程总是优于同步编程：虽然异步编程可以提高应用程序的可扩展性和响应性，但它可能并不总是最好的解决方案。异步编程可能会引入额外的复杂性，而且对于所有的用例可能都不是必需需要的
异步编程可以完全消除对线程的需求：虽然异步编程可以减少显式线程的需求，但它并不能完全消除它。异步编程仍然依赖于底层线程和线程池在后台执行任务
还有并不能完全消除锁和同步的需求、或认为异步容易调试等等
关键字 async 和 await
目标 支持读起来像一连串语句的代码，但会根据外部资源分配和任务完成时间以更复杂的顺序执行
内容 async 用以标记函数的关键字，例如：
public async Task TestAsync(){ } 但仅这还不是真正的异步函数
await 必须在 async 标记下的函数内使用的关键字，例如：
public async Task TestAsync() { await Task.delay(1000); Console.WriteLine(&#34;TestDone&#34;); } async 和 await 一起使用才构成了异步函数
如此例所示，await 关键字将暂停 TestAsync 方法的执行，并返回不完整的 Task，在此期间，线程将返回到线程池，以便自己可用于另一个请求，await 完成后将恢复继续向下执行
但是，如何知道 await 已经完成呢？这里就需要用到 Task，可先了解一下此站另一个 blog - 线程
总结 该操作不会在线程池线程运行
如果仅使用 async 关键字，那么函数内容仍会以同步方式进行
一般异步函数命名的最后结尾都是 Async"><meta name=author content="Me"><link rel=canonical href=https://brealinhub.com/posts/%E5%BC%82%E6%AD%A5/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c90ce37b18981f885b1cc08faf9cc8c453a1933d0b9e9145780290f37caa9d8f.css integrity="sha256-yQzjexiYH4hbHMCPr5zIxFOhkz0LnpFFeAKQ83yqnY8=" rel="preload stylesheet" as=style><link rel=icon href=https://brealinhub.com/favicon.ico><link rel=apple-touch-icon href=https://brealinhub.com/apple-touch-icon.png><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-9GSM0N8QP8","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta name=twitter:card content="summary"><meta name=twitter:title content="异步 | brealinblog"><meta name=twitter:description content="查阅 MSDN 异步编程以了解更多
异步编程 在 C# 中，异步编程是一种编程范式，它允许程序异步执行任务，而不会阻塞主线程或其他任务的执行。在异步程序中，程序可以继续执行其他任务，而无需等待一个任务完成
优势 异步编程可以为需要执行 I/O 操作或其他耗时任务的应用程序提供显著的优势，例如访问数据库、下载文件或执行网络通信。通过使用异步编程，应用程序可以提高性能、响应性、可扩展性和资源效率，同时简化代码并提高容错性
误解 异步编程总是更快：虽然异步编程可以提高性能，但它并不能保证在所有情况下都能提供更快的执行速度，如果一个应用程序没有大量的 I/O 操作或耗时任务，使用异步编程可能不会提供任何性能优势，甚至可能引入不必要的复杂性
异步编程总是优于同步编程：虽然异步编程可以提高应用程序的可扩展性和响应性，但它可能并不总是最好的解决方案。异步编程可能会引入额外的复杂性，而且对于所有的用例可能都不是必需需要的
异步编程可以完全消除对线程的需求：虽然异步编程可以减少显式线程的需求，但它并不能完全消除它。异步编程仍然依赖于底层线程和线程池在后台执行任务
还有并不能完全消除锁和同步的需求、或认为异步容易调试等等
关键字 async 和 await
目标 支持读起来像一连串语句的代码，但会根据外部资源分配和任务完成时间以更复杂的顺序执行
内容 async 用以标记函数的关键字，例如：
public async Task TestAsync(){ } 但仅这还不是真正的异步函数
await 必须在 async 标记下的函数内使用的关键字，例如：
public async Task TestAsync() { await Task.delay(1000); Console.WriteLine(&#34;TestDone&#34;); } async 和 await 一起使用才构成了异步函数
如此例所示，await 关键字将暂停 TestAsync 方法的执行，并返回不完整的 Task，在此期间，线程将返回到线程池，以便自己可用于另一个请求，await 完成后将恢复继续向下执行
但是，如何知道 await 已经完成呢？这里就需要用到 Task，可先了解一下此站另一个 blog - 线程
总结 该操作不会在线程池线程运行
如果仅使用 async 关键字，那么函数内容仍会以同步方式进行
一般异步函数命名的最后结尾都是 Async"><meta property="og:title" content="异步 | brealinblog"><meta property="og:description" content="查阅 MSDN 异步编程以了解更多
异步编程 在 C# 中，异步编程是一种编程范式，它允许程序异步执行任务，而不会阻塞主线程或其他任务的执行。在异步程序中，程序可以继续执行其他任务，而无需等待一个任务完成
优势 异步编程可以为需要执行 I/O 操作或其他耗时任务的应用程序提供显著的优势，例如访问数据库、下载文件或执行网络通信。通过使用异步编程，应用程序可以提高性能、响应性、可扩展性和资源效率，同时简化代码并提高容错性
误解 异步编程总是更快：虽然异步编程可以提高性能，但它并不能保证在所有情况下都能提供更快的执行速度，如果一个应用程序没有大量的 I/O 操作或耗时任务，使用异步编程可能不会提供任何性能优势，甚至可能引入不必要的复杂性
异步编程总是优于同步编程：虽然异步编程可以提高应用程序的可扩展性和响应性，但它可能并不总是最好的解决方案。异步编程可能会引入额外的复杂性，而且对于所有的用例可能都不是必需需要的
异步编程可以完全消除对线程的需求：虽然异步编程可以减少显式线程的需求，但它并不能完全消除它。异步编程仍然依赖于底层线程和线程池在后台执行任务
还有并不能完全消除锁和同步的需求、或认为异步容易调试等等
关键字 async 和 await
目标 支持读起来像一连串语句的代码，但会根据外部资源分配和任务完成时间以更复杂的顺序执行
内容 async 用以标记函数的关键字，例如：
public async Task TestAsync(){ } 但仅这还不是真正的异步函数
await 必须在 async 标记下的函数内使用的关键字，例如：
public async Task TestAsync() { await Task.delay(1000); Console.WriteLine(&#34;TestDone&#34;); } async 和 await 一起使用才构成了异步函数
如此例所示，await 关键字将暂停 TestAsync 方法的执行，并返回不完整的 Task，在此期间，线程将返回到线程池，以便自己可用于另一个请求，await 完成后将恢复继续向下执行
但是，如何知道 await 已经完成呢？这里就需要用到 Task，可先了解一下此站另一个 blog - 线程
总结 该操作不会在线程池线程运行
如果仅使用 async 关键字，那么函数内容仍会以同步方式进行
一般异步函数命名的最后结尾都是 Async"><meta property="og:type" content="article"><meta property="og:url" content="https://brealinhub.com/posts/%E5%BC%82%E6%AD%A5/"><meta property="og:image" content="https://brealinhub.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-06T19:14:07+00:00"><meta property="article:modified_time" content="2023-03-06T19:14:07+00:00"><meta property="og:site_name" content="brealinblog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://brealinhub.com/posts/"},{"@type":"ListItem","position":2,"name":"异步","item":"https://brealinhub.com/posts/%E5%BC%82%E6%AD%A5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"异步 | brealinblog","name":"异步","description":"查阅 MSDN 异步编程以了解更多\n异步编程 在 C# 中，异步编程是一种编程范式，它允许程序异步执行任务，而不会阻塞主线程或其他任务的执行。在异步程序中，程序可以继续执行其他任务，而无需等待一个任务完成\n优势 异步编程可以为需要执行 I/O 操作或其他耗时任务的应用程序提供显著的优势，例如访问数据库、下载文件或执行网络通信。通过使用异步编程，应用程序可以提高性能、响应性、可扩展性和资源效率，同时简化代码并提高容错性\n误解 异步编程总是更快：虽然异步编程可以提高性能，但它并不能保证在所有情况下都能提供更快的执行速度，如果一个应用程序没有大量的 I/O 操作或耗时任务，使用异步编程可能不会提供任何性能优势，甚至可能引入不必要的复杂性\n异步编程总是优于同步编程：虽然异步编程可以提高应用程序的可扩展性和响应性，但它可能并不总是最好的解决方案。异步编程可能会引入额外的复杂性，而且对于所有的用例可能都不是必需需要的\n异步编程可以完全消除对线程的需求：虽然异步编程可以减少显式线程的需求，但它并不能完全消除它。异步编程仍然依赖于底层线程和线程池在后台执行任务\n还有并不能完全消除锁和同步的需求、或认为异步容易调试等等\n关键字 async 和 await\n目标 支持读起来像一连串语句的代码，但会根据外部资源分配和任务完成时间以更复杂的顺序执行\n内容 async 用以标记函数的关键字，例如：\npublic async Task TestAsync(){ } 但仅这还不是真正的异步函数\nawait 必须在 async 标记下的函数内使用的关键字，例如：\npublic async Task TestAsync() { await Task.delay(1000); Console.WriteLine(\u0026#34;TestDone\u0026#34;); } async 和 await 一起使用才构成了异步函数\n如此例所示，await 关键字将暂停 TestAsync 方法的执行，并返回不完整的 Task，在此期间，线程将返回到线程池，以便自己可用于另一个请求，await 完成后将恢复继续向下执行\n但是，如何知道 await 已经完成呢？这里就需要用到 Task，可先了解一下此站另一个 blog - 线程\n总结 该操作不会在线程池线程运行\n如果仅使用 async 关键字，那么函数内容仍会以同步方式进行\n一般异步函数命名的最后结尾都是 Async","keywords":["C#"],"wordCount":"1242","inLanguage":"en","datePublished":"2023-03-06T19:14:07Z","dateModified":"2023-03-06T19:14:07Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://brealinhub.com/posts/%E5%BC%82%E6%AD%A5/"},"publisher":{"@type":"Organization","name":"brealinblog","logo":{"@type":"ImageObject","url":"https://brealinhub.com/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://brealinhub.com/ accesskey=h title="brealinblog (Alt + H)">brealinblog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://brealinhub.com/tags/ title=Tags>Tags</a></li><li><a href=https://brealinhub.com/archives/ title=Archive>Archive</a></li><li><a href=https://brealinhub.com/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://brealinhub.com/ title=@brealin class=active target=_blank>@brealin<span class=external-link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://brealinhub.com/>Home</a>&nbsp;»&nbsp;<a href=https://brealinhub.com/posts/>Posts</a></div><h1 class=post-title>异步</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>March 6, 2023</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://brealinhub.com/tags/c#/>C#</a></span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b aria-label=异步编程>异步编程</a><ul><li><a href=#%e4%bc%98%e5%8a%bf aria-label=优势>优势</a></li><li><a href=#%e8%af%af%e8%a7%a3 aria-label=误解>误解</a></li></ul></li><li><a href=#%e5%85%b3%e9%94%ae%e5%ad%97 aria-label=关键字>关键字</a><ul><li><a href=#%e7%9b%ae%e6%a0%87 aria-label=目标>目标</a></li><li><a href=#%e5%86%85%e5%ae%b9 aria-label=内容>内容</a><ul><li><a href=#async aria-label=async>async</a></li><li><a href=#await aria-label=await>await</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li></ul></li><li><a href=#task aria-label=Task>Task</a><ul><li><a href=#%e4%bc%98%e5%8a%bf-1 aria-label=优势>优势</a></li><li><a href=#%e6%af%94%e8%be%83 aria-label=比较>比较</a><ul><li><a href=#%e4%be%8b%e4%b8%80 aria-label=例一>例一</a></li><li><a href=#%e4%be%8b%e4%ba%8c aria-label=例二>例二</a></li></ul></li><li><a href=#tap aria-label=TAP>TAP</a></li></ul></li><li><a href=#%e6%ad%bb%e9%94%81 aria-label=死锁>死锁</a><ul><li><a href=#%e5%86%85%e5%ae%b9-1 aria-label=内容>内容</a></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%8e%aa%e6%96%bd aria-label=解决措施>解决措施</a></li></ul></li><li><a href=#%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=上下文>上下文</a><ul><li><a href=#%e5%bd%93%e5%89%8d%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=当前上下文>当前上下文</a></li><li><a href=#%e7%90%86%e8%a7%a3 aria-label=理解>理解</a></li><li><a href=#%e7%a4%ba%e4%be%8b aria-label=示例>示例</a></li></ul></li><li><a href=#%e5%bc%82%e5%b8%b8%e6%8d%95%e8%8e%b7 aria-label=异常捕获>异常捕获</a></li><li><a href=#%e6%8e%a7%e5%88%b6%e5%8f%b0%e7%a8%8b%e5%ba%8f aria-label=控制台程序>控制台程序</a><ul><li><a href=#%e5%8e%9f%e5%9b%a0 aria-label=原因>原因</a></li><li><a href=#%e8%a7%a3%e5%86%b3 aria-label=解决>解决</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93-1 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><blockquote><p>查阅 MSDN <a href=https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/>异步编程</a>以了解更多</p></blockquote><h1 id=异步编程>异步编程<a hidden class=anchor aria-hidden=true href=#异步编程>¶</a></h1><p>在 C# 中，异步编程是一种编程范式，它允许程序异步执行任务，而不会阻塞主线程或其他任务的执行。在异步程序中，程序可以继续执行其他任务，而无需等待一个任务完成</p><h2 id=优势>优势<a hidden class=anchor aria-hidden=true href=#优势>¶</a></h2><p>异步编程可以为需要执行 I/O 操作或其他耗时任务的应用程序提供显著的优势，例如访问数据库、下载文件或执行网络通信。通过使用异步编程，应用程序可以提高性能、响应性、可扩展性和资源效率，同时简化代码并提高容错性</p><h2 id=误解>误解<a hidden class=anchor aria-hidden=true href=#误解>¶</a></h2><ol><li><p>异步编程总是更快：虽然异步编程可以提高性能，但它并不能保证在所有情况下都能提供更快的执行速度，如果一个应用程序没有大量的 I/O 操作或耗时任务，使用异步编程可能不会提供任何性能优势，甚至可能引入不必要的复杂性</p></li><li><p>异步编程总是优于同步编程：虽然异步编程可以提高应用程序的可扩展性和响应性，但它可能并不总是最好的解决方案。异步编程可能会引入额外的复杂性，而且对于所有的用例可能都不是必需需要的</p></li><li><p>异步编程可以完全消除对线程的需求：虽然异步编程可以减少显式线程的需求，但它并不能完全消除它。异步编程仍然依赖于底层线程和线程池在后台执行任务</p></li></ol><p>还有并不能完全消除锁和同步的需求、或认为异步容易调试等等</p><h1 id=关键字>关键字<a hidden class=anchor aria-hidden=true href=#关键字>¶</a></h1><p><code>async</code> 和 <code>await</code></p><h2 id=目标>目标<a hidden class=anchor aria-hidden=true href=#目标>¶</a></h2><p>支持读起来像一连串语句的代码，但会根据外部资源分配和任务完成时间以更复杂的顺序执行</p><h2 id=内容>内容<a hidden class=anchor aria-hidden=true href=#内容>¶</a></h2><h3 id=async>async<a hidden class=anchor aria-hidden=true href=#async>¶</a></h3><p>用以标记函数的关键字，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>async</span> <span class=n>Task</span> <span class=n>TestAsync</span><span class=p>(){</span> <span class=p>}</span>
</span></span></code></pre></div><p>但仅这还不是真正的异步函数</p><h3 id=await>await<a hidden class=anchor aria-hidden=true href=#await>¶</a></h3><p>必须在 <code>async</code> 标记下的函数内使用的关键字，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>async</span> <span class=n>Task</span> <span class=n>TestAsync</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>await</span> <span class=n>Task</span><span class=p>.</span><span class=n>delay</span><span class=p>(</span><span class=m>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;TestDone&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>async</code> 和 <code>await</code> 一起使用才构成了异步函数</p><p>如此例所示，<code>await </code>关键字将暂停 <code>TestAsync</code> 方法的执行，并返回不完整的 <code>Task</code>，在此期间，线程将返回到线程池，以便自己可用于另一个请求，<code>await</code> 完成后将恢复继续向下执行</p><p>但是，如何知道 <code>await</code> 已经完成呢？这里就需要用到 <code>Task</code>，可先了解一下此站另一个 blog - <a href=https://brealinhub.com/2023/03/03/%E7%BA%BF%E7%A8%8B/>线程</a></p><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>¶</a></h3><ul><li><p>该操作不会在线程池线程运行</p></li><li><p>如果仅使用 <code>async</code> 关键字，那么函数内容仍会以同步方式进行</p></li><li><p>一般异步函数命名的最后结尾都是 Async</p></li><li><p>帮助我们从异步操作中提取结果</p></li><li><p>验证操作成功</p></li><li><p>提供在异步方法中执行其余代码的延续</p></li></ul><h1 id=task>Task<a hidden class=anchor aria-hidden=true href=#task>¶</a></h1><p><code>Task</code> 抽象类是在 C# 5.0 (.NET Framwork 4.0) 引出的概念</p><p>大多数情况下，都是返回 <code>Task</code> 或者 <code>Task&lt;T></code>，极少数情况会返回 <code>void</code></p><p>因为 <code>Task</code> 返回类型可提供更加丰富的监视内容和可等待内容结果，而 <code>void</code> 没有这些，仅在异步事件处理程序使用 <code>void</code> 返回类型</p><h2 id=优势-1>优势<a hidden class=anchor aria-hidden=true href=#优势-1>¶</a></h2><ol><li><p>抽象类允许我们轻松的使用线程池和本地线程，且绝大多数 <code>Task</code> 都在属于线程池的后台线程中执行</p></li><li><p>异步操作的状态管理：<code>Task</code> 对象跟踪异步操作的状态，包括是否已经完成、是否已经取消、是否已经出错等等，开发人员可以通过访问 <code>Task</code> 的属性和方法来获取和操作异步操作的状态信息</p></li><li><p>异步操作的结果返回：<code>Task</code> 对象代表异步操作的最终结果，当异步操作完成时，它可以返回异步操作的结果或者抛出异常。异步方法的返回值通常是一个 <code>Task</code> 对象或者 <code>Task&lt;T></code> 对象，开发人员可以通过访问 <code>Task</code> 对象的 <code>Result</code> 属性或者使用 <code>await</code> 关键字来获取异步操作的结果</p></li><li><p>异步操作的协调和组合：<code>Task</code> 对象可以通过多种方式来协调和组合异步操作，例如使用 <code>Task.WhenAll</code> 或 <code>Task.WhenAny</code> 方法来等待多个异步操作的完成或者组合多个异步操作的结果</p></li><li><p>并行和异步编程的支持：<code>Task</code> 对象可以帮助开发人员实现并行和异步编程模式，使用异步方法和异步操作可以提高应用程序的性能和响应性，避免阻塞 UI 线程或者阻塞 CPU</p></li></ol><p><code>Task</code> 对象不是线程，也不会创建线程，它只是代表了异步操作的状态和行为。异步操作的实际执行可能在线程池线程、IO 线程、UI 线程或者其它线程中执行，具体取决于异步操作的实现方式和上下文</p><h2 id=比较>比较<a hidden class=anchor aria-hidden=true href=#比较>¶</a></h2><h3 id=例一>例一<a hidden class=anchor aria-hidden=true href=#例一>¶</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>mres</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ManualResetEventSlim</span><span class=p>(</span><span class=k>false</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=n>ThreadPool</span><span class=p>.</span><span class=n>QueueUserWorkItem</span><span class=p>&lt;</span><span class=n>ManualResetEventSlim</span><span class=p>&gt;((</span><span class=n>_msg</span><span class=p>)</span> <span class=p>=&gt;</span>   
</span></span><span class=line><span class=cl>    <span class=p>{</span>   
</span></span><span class=line><span class=cl>		<span class=n>i</span> <span class=p>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>Exp</span><span class=p>(</span><span class=m>1</span><span class=p>);</span>   
</span></span><span class=line><span class=cl>        <span class=n>mres</span><span class=p>.</span><span class=n>Set</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=n>mres</span><span class=p>,</span> <span class=k>false</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>mres</span><span class=p>.</span><span class=n>Wait</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// output:2.71828182845</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上面这个例子首先创建了 <code>ManualResetEventSlim</code> API 与其中的 <code>Set</code> 和 <code>Wait</code> 方法来控制线程池运行，再创建线程池执行内容</p><p>现在，我们可以用如下 <code>Task</code> 来简化操作</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>task</span> <span class=p>=</span> <span class=n>Task</span><span class=p>.</span><span class=n>Run</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=n>Math</span><span class=p>.</span><span class=n>Exp</span><span class=p>(</span><span class=m>1</span><span class=p>));</span>  
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>task</span><span class=p>.</span><span class=n>Result</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output:2.71828182845</span>
</span></span></code></pre></div><p>与用前一个 <code>ThredPool</code> 类方法相比，<code>Task</code> 省去了创建变量和控制线程发生的过程，且用前个方法不能返回类型，而此方法在这个例子中，返回了 <code>Task&lt;double></code> 类型（具有 Result 属性）</p><h3 id=例二>例二<a hidden class=anchor aria-hidden=true href=#例二>¶</a></h3><p>in <code>BaseClass.cs</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>CarBuilding</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>static</span> <span class=n>Body</span> <span class=n>BuildBody</span><span class=p>(</span><span class=kt>int</span> <span class=n>weight</span><span class=p>,</span> <span class=kt>int</span> <span class=n>length</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=k>new</span> <span class=n>Body</span><span class=p>(</span><span class=n>weight</span><span class=p>,</span> <span class=n>length</span><span class=p>,</span> <span class=n>width</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>static</span> <span class=n>Engine</span> <span class=n>BuildEngine</span><span class=p>(</span><span class=kt>int</span> <span class=n>horsePower</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=k>new</span> <span class=n>Engine</span><span class=p>(</span><span class=n>horsePower</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>static</span> <span class=n>Suspension</span> <span class=n>BuildSuspension</span><span class=p>(</span><span class=kt>int</span> <span class=n>supportedKg</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=k>new</span> <span class=n>Suspension</span><span class=p>(</span><span class=n>supportedKg</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>static</span> <span class=n>Painting</span> <span class=n>Paint</span><span class=p>(</span><span class=kt>string</span> <span class=n>color</span><span class=p>,</span> <span class=kt>int</span> <span class=n>bodyArea</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=k>new</span> <span class=n>Painting</span><span class=p>(</span><span class=n>color</span><span class=p>,</span> <span class=n>bodyArea</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>private</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Test</span><span class=p>(</span><span class=n>Body</span> <span class=n>body</span><span class=p>,</span> <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>Suspension</span><span class=p>&gt;</span> <span class=n>suspensions</span><span class=p>,</span> <span class=n>Engine</span> <span class=n>engine</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>	<span class=p>{</span>  
</span></span><span class=line><span class=cl>	    <span class=k>if</span> <span class=p>(</span><span class=n>suspensions</span><span class=p>.</span><span class=n>Sum</span><span class=p>(</span><span class=n>s</span> <span class=p>=&gt;</span> <span class=n>s</span><span class=p>.</span><span class=n>SupportedKg</span><span class=p>)</span> <span class=p>&lt;=</span> <span class=n>body</span><span class=p>.</span><span class=n>Weight</span> <span class=p>||</span> <span class=n>engine</span><span class=p>.</span><span class=n>Horsepower</span> <span class=p>*</span> <span class=m>4</span> <span class=p>&lt;=</span> <span class=n>body</span><span class=p>.</span><span class=n>Weight</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>	        <span class=k>throw</span> <span class=k>new</span> <span class=n>ArgumentException</span><span class=p>(</span><span class=s>&#34;The car weighs too much&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Body</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>Body</span><span class=p>(</span><span class=kt>int</span> <span class=n>weight</span><span class=p>,</span> <span class=kt>int</span> <span class=n>length</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    <span class=n>Weight</span> <span class=p>=</span> <span class=n>weight</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>        <span class=n>Length</span> <span class=p>=</span> <span class=n>length</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>        <span class=n>Width</span> <span class=p>=</span> <span class=n>weight</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;{Weight} and {Length} and {Width}&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>   
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>int</span> <span class=n>Weight</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>int</span> <span class=n>Length</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>int</span> <span class=n>Width</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Engine</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>Engine</span><span class=p>(</span><span class=kt>int</span> <span class=n>horsePower</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    <span class=n>Horsepower</span> <span class=p>=</span> <span class=n>horsePower</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>   
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>int</span> <span class=n>Horsepower</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Suspension</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>Suspension</span><span class=p>(</span><span class=kt>int</span> <span class=n>supportedKg</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    <span class=n>SupportedKg</span> <span class=p>=</span> <span class=n>supportedKg</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>	    
</span></span><span class=line><span class=cl>		<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>SupportedKg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>int</span> <span class=n>SupportedKg</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Painting</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>Painting</span><span class=p>(</span><span class=kt>string</span> <span class=n>color</span><span class=p>,</span> <span class=kt>int</span> <span class=n>bodyArea</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    <span class=n>Color</span> <span class=p>=</span> <span class=n>color</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>        <span class=n>BodyArea</span> <span class=p>=</span> <span class=n>bodyArea</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;{Color} and {BodyArea}&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>string</span> <span class=n>Color</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>int</span> <span class=n>BodyArea</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 <code>Main</code> 函数中添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>Body</span> <span class=n>body</span> <span class=p>=</span> <span class=k>null</span><span class=p>!;</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>bodyThread</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=p>(()</span> <span class=p>=&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>body</span> <span class=p>=</span> <span class=n>BuildBody</span><span class=p>(</span><span class=m>100</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>2</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=p>});</span>    
</span></span><span class=line><span class=cl>    <span class=n>bodyThread</span><span class=p>.</span><span class=n>Start</span><span class=p>();</span>  <span class=c1>// Thread 方法</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>bodyTask</span> <span class=p>=</span> <span class=n>Task</span><span class=p>.</span><span class=n>Run</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=n>BuildBody</span><span class=p>(</span><span class=m>50</span><span class=p>,</span><span class=m>1</span><span class=p>,</span><span class=m>1</span><span class=p>));</span>  <span class=c1>// Task 方法</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// output: </span>
</span></span><span class=line><span class=cl>	<span class=c1>// 100 and 5 and 100</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 50 and 1 and 50</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里两个方法有着区别，<code>Task</code> 在这更具优势，上文也有提到（简洁、具有返回值）</p><p>继续往 <code>Main</code> 函数添加内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>Body</span> <span class=n>body</span> <span class=p>=</span> <span class=k>null</span><span class=p>!;</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>bodyThread</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=p>(()</span> <span class=p>=&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>body</span> <span class=p>=</span> <span class=n>BuildBody</span><span class=p>(</span><span class=m>100</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>2</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=p>});</span>    
</span></span><span class=line><span class=cl>    <span class=n>bodyThread</span><span class=p>.</span><span class=n>Start</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>bodyThread</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=n>Painting</span> <span class=n>painting</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>paintingThread</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=p>(()</span> <span class=p>=&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>painting</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Painting</span><span class=p>(</span><span class=s>&#34;red&#34;</span><span class=p>,</span> <span class=n>body</span><span class=p>.</span><span class=n>Width</span> <span class=p>*</span> <span class=n>body</span><span class=p>.</span><span class=n>Length</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=p>});}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=n>paintingThread</span><span class=p>.</span><span class=n>Start</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>paintingThread</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// output:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 100 and 5 and 100</span>
</span></span><span class=line><span class=cl>	<span class=c1>// red and 500</span>
</span></span></code></pre></div><p>上面内容用的 <code>Thread</code> 写法写出两个子线程运行的方法，下面写一个 <code>Task</code> 写法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>bodyTask</span> <span class=p>=</span> <span class=n>Task</span><span class=p>.</span><span class=n>Run</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=n>BuildBody</span><span class=p>(</span><span class=m>50</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>2</span><span class=p>));</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>paintingTask</span> <span class=p>=</span> <span class=n>bodyTask</span><span class=p>.</span><span class=n>ContinueWith</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>        <span class=n>task</span> <span class=p>=&gt;</span> <span class=n>Paint</span><span class=p>(</span><span class=s>&#34;red&#34;</span><span class=p>,</span> <span class=n>task</span><span class=p>.</span><span class=n>Result</span><span class=p>.</span><span class=n>Width</span> <span class=p>*</span> <span class=n>task</span><span class=p>.</span><span class=n>Result</span><span class=p>.</span><span class=n>Length</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// output:</span>
</span></span><span class=line><span class=cl><span class=c1>// 50 and 5 and 50</span>
</span></span><span class=line><span class=cl><span class=c1>// red and 250</span>
</span></span></code></pre></div><p>比较一下，用 <code>Task </code>方法显而易见的简洁了，其中采用了<strong>链式编程</strong>，使用了 <code>ContinueWith</code> 方法，意思是执行 <code>bodyTask</code> 线程池，并开始函数内部委托的执行，使任务之间的依赖性清晰且定义明确</p><p>而且 <code>ContinueWith</code> 方法也提供第二个参数，如写法：<code>task => Paint("red", task.Result.Width * task.Result.Length),TaskContinuationOptions.OnlyOnRanToCompletion</code>，第二个参数就表明前一个线程池必须完成后才执行此委托</p><p>在 Main 函数中添加以下内容：</p><p><code>Thread</code> 多个线程创建并执行写法</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Collections.Concurrent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>------------------------------------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>suspensions</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ConcurrentBag</span><span class=p>&lt;</span><span class=n>Suspension</span><span class=p>&gt;();</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>suspensionThreads</span> <span class=p>=</span> <span class=n>Enumerable</span>  
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Range</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>10</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Select</span><span class=p>(</span><span class=n>i</span> <span class=p>=&gt;</span>  
</span></span><span class=line><span class=cl>        <span class=p>{</span>  
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>t</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=p>(()</span> <span class=p>=&gt;</span>  
</span></span><span class=line><span class=cl>            <span class=p>{</span>  
</span></span><span class=line><span class=cl>                <span class=n>suspensions</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>BuildSuspension</span><span class=p>(</span><span class=m>40</span><span class=p>));</span>  
</span></span><span class=line><span class=cl>            <span class=p>});</span>            
</span></span><span class=line><span class=cl>            <span class=n>t</span><span class=p>.</span><span class=n>Start</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>t</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>        <span class=p>});</span>  
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=kt>var</span> <span class=n>suspThread</span> <span class=k>in</span> <span class=n>suspensionThreads</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=n>suspThread</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// output：40 40 40 ... 40 40 (10 个 40)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>ConcurrentBag</code>：表示线程安全、无序的对象集合</p><p>这个 API 就是为了解决多个线程池的性能问题</p><p>而用 <code>Task</code> 创建则无需此步骤，如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>suspensionTasks</span> <span class=p>=</span> <span class=n>Enumerable</span>  
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Range</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>10</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Select</span><span class=p>(</span><span class=n>i</span> <span class=p>=&gt;</span> <span class=n>Task</span><span class=p>.</span><span class=n>Run</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=n>BuildSuspension</span><span class=p>(</span><span class=m>40</span><span class=p>)));</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>suspensionsTask</span> <span class=p>=</span> <span class=n>Task</span><span class=p>.</span><span class=n>WhenAll</span><span class=p>(</span><span class=n>suspensionTasks</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>ContinueWith</span><span class=p>(</span><span class=n>task</span> <span class=p>=&gt;</span> <span class=n>task</span><span class=p>.</span><span class=n>Result</span><span class=p>.</span><span class=n>ToList</span><span class=p>());</span>  
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=c1>// output：40 40 40 ... 40 40 (10 个 40)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>同样省略了很多步骤，在里面使用了 <code>WhenAll</code> 方法，表明执行完所有内容并返回一个 <code>Task&lt;T></code> 类型</p><p>也可进一步优化为：<code>Task.Factory.ContinueWhenAll(suspensionTasks, tasks => tasks.ToList());</code></p><p>在 <code>Main</code> 函数添加以下内容：</p><p>用 <code>Thread</code> 表示线程抛出异常</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>Exception</span><span class=p>?</span> <span class=n>thrownException</span> <span class=p>=</span> <span class=k>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>body</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Body</span><span class=p>(</span><span class=m>1</span><span class=p>,</span><span class=m>1</span><span class=p>,</span><span class=m>1</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>Suspension</span><span class=p>&gt;</span> <span class=n>suspensions</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Suspension</span><span class=p>[</span><span class=m>1</span><span class=p>];</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>engine</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Engine</span><span class=p>(</span><span class=m>1</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>testing</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=p>(()</span> <span class=p>=&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=k>try</span>  
</span></span><span class=line><span class=cl>        <span class=p>{</span>  
</span></span><span class=line><span class=cl>            <span class=n>Test</span><span class=p>(</span><span class=n>body</span><span class=p>,</span> <span class=n>suspensions</span><span class=p>,</span> <span class=n>engine</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>        
</span></span><span class=line><span class=cl>        <span class=k>catch</span> <span class=p>(</span><span class=n>Exception</span> <span class=n>exc</span><span class=p>)</span>   
</span></span><span class=line><span class=cl>        <span class=p>{</span>   
</span></span><span class=line><span class=cl>            <span class=n>thrownException</span> <span class=p>=</span> <span class=n>exc</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>    
</span></span><span class=line><span class=cl>        <span class=p>});</span>    
</span></span><span class=line><span class=cl>        <span class=n>testing</span><span class=p>.</span><span class=n>Start</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=n>testing</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>thrownException</span> <span class=k>is</span> <span class=n>not</span> <span class=k>null</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>thrownException</span><span class=p>;</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>只有当线程抛出异常，才会使 <code>thrownException</code> 有值，没有异常则是 <code>null</code></p><p><code>Tasks</code> 方法同样有内置工具检测异常，如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>body</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Body</span><span class=p>(</span><span class=m>1</span><span class=p>,</span><span class=m>1</span><span class=p>,</span><span class=m>1</span><span class=p>);</span>    
</span></span><span class=line><span class=cl>	<span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>Suspension</span><span class=p>&gt;</span> <span class=n>suspensions</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Suspension</span><span class=p>[</span><span class=m>1</span><span class=p>];</span>    
</span></span><span class=line><span class=cl>	<span class=kt>var</span> <span class=n>engine</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Engine</span><span class=p>(</span><span class=m>1</span><span class=p>);</span>   
</span></span><span class=line><span class=cl>	<span class=k>try</span>   
</span></span><span class=line><span class=cl>	<span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>testingTask</span> <span class=p>=</span> <span class=n>Task</span><span class=p>.</span><span class=n>Run</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>            <span class=p>()</span> <span class=p>=&gt;</span> <span class=n>Test</span><span class=p>(</span><span class=n>body</span><span class=p>,</span> <span class=n>suspensions</span><span class=p>,</span><span class=n>engine</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>);</span>    
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(</span><span class=n>AggregateException</span> <span class=n>exc</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    <span class=k>throw</span> <span class=n>exc</span><span class=p>.</span><span class=n>InnerExceptions</span><span class=p>[</span><span class=m>0</span><span class=p>];</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这种情况下，我们只重新抛出第一个内部异常，但我们也可以使用<code>AgggregateException.Handle()</code> 方法处理它</p><h2 id=tap>TAP<a hidden class=anchor aria-hidden=true href=#tap>¶</a></h2><p><a href="https://www.microsoft.com/download/en/details.aspx?id=19957">Task-based Asynchronous Pattern</a> 基于 <code>Task</code>的异步编程模型</p><p>了解任务代表异步方法的执行而不是结果非常重要，<code>Task</code> 有几个属性，指示操作是否成功完成（状态、已完成、取消、错误）</p><h1 id=死锁>死锁<a hidden class=anchor aria-hidden=true href=#死锁>¶</a></h1><p>一般出现在 UI 或 ASP.NET 程序中</p><h2 id=内容-1>内容<a hidden class=anchor aria-hidden=true href=#内容-1>¶</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>static</span> <span class=kt>object</span> <span class=n>lock1</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>object</span><span class=p>();</span>  
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>object</span> <span class=n>lock2</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>object</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>Thread</span> <span class=n>t1</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=p>(</span><span class=n>DoWork1</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=n>Thread</span> <span class=n>t2</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=p>(</span><span class=n>DoWork2</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=n>t1</span><span class=p>.</span><span class=n>Start</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=n>t2</span><span class=p>.</span><span class=n>Start</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=n>t1</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=n>t2</span><span class=p>.</span><span class=n>Join</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Done.&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>void</span> <span class=n>DoWork1</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>lock</span> <span class=p>(</span><span class=n>lock1</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Thread 1 acquired lock1.&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>        <span class=n>Thread</span><span class=p>.</span><span class=n>Sleep</span><span class=p>(</span><span class=m>1000</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>        <span class=k>lock</span> <span class=p>(</span><span class=n>lock2</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>{</span>            
</span></span><span class=line><span class=cl>	        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Thread 1 acquired lock2.&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>void</span> <span class=n>DoWork2</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>lock</span> <span class=p>(</span><span class=n>lock2</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Thread 2 acquired lock2.&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>        <span class=n>Thread</span><span class=p>.</span><span class=n>Sleep</span><span class=p>(</span><span class=m>1000</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>        <span class=k>lock</span> <span class=p>(</span><span class=n>lock1</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>{</span>            
</span></span><span class=line><span class=cl>	        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Thread 2 acquired lock1.&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上面的代码中，定义了两个锁对象 <code>lock1</code> 和 <code>lock2</code>，然后创建了两个线程 <code>t1</code> 和 <code>t2</code>，分别在 <code>DoWork1</code> 和 <code>DoWork2</code> 方法中获取锁。然后在这两个方法中互相等待对方释放锁，导致程序陷入死锁状态。运行程序后，程序将无法继续执行下去，需要手动终止程序。为了避免死锁，我们需要使用合适的同步和互斥机制，避免线程之间的互相等待</p><blockquote><p><code>lock</code> 代码块是 C# 中用于实现线程同步的机制。<code>lock</code> 关键字可以将一段代码块标记为“临界区”，确保同一时刻只有一个线程可以进入这个代码块，从而避免多个线程同时访问共享资源，导致数据竞争和不确定性的问题，在上述示例中进入 <code>lock</code> 代码块之前，线程会尝试获取 <code>lock1</code> 的锁，如果这个锁当前没有被其他线程占用，那么线程将获取到锁，并进入临界区代码。在临界区代码执行完成之后，线程会释放锁，以便其他线程可以获取锁进入临界区</p></blockquote><p>也尽量减少使用 <code>Result</code> 或 <code>GetResult</code> 或 <code>Wait</code> 等方法（在某些地方适用，如控制台程序）</p><blockquote><p><code>Result</code> 属性为阻止属性。 如果你在其任务完成之前尝试访问它，当前处于活动状态的线程将被阻止，直到任务完成且值为可用。 在大多数情况下，应通过使用 <code>await</code> 访问此值，而不是直接访问属性</p></blockquote><p>该函数内容需要阻止主线程而等待新开的线程先完成，这可能会导致死锁，这正是我们试图避免使用异步和等待关键字的事情</p><h2 id=解决措施>解决措施<a hidden class=anchor aria-hidden=true href=#解决措施>¶</a></h2><ul><li><p>代码同步化，不争抢线程资源</p></li><li><p>不使用 <code>await</code> 关键字</p></li><li><p>使用 <code>ConfigureAwait()</code></p></li></ul><h1 id=上下文>上下文<a hidden class=anchor aria-hidden=true href=#上下文>¶</a></h1><p>上下文（Context）是一种用于在不同线程之间共享数据的机制。上下文对象可以在一个线程中创建，并在另一个线程中使用，它可以是线程上下文、进程上下文、同步上下文、应用程序域上下文、执行上下文等等</p><p>指程序中当前执行代码的环境或状态。可以将上下文视为一个程序运行时的快照，其中包含了程序的当前状态、已定义的变量、对象以及正在执行的代码的位置等信息</p><h2 id=当前上下文>当前上下文<a hidden class=anchor aria-hidden=true href=#当前上下文>¶</a></h2><p>通常也指异步上下文，它与线程池线程一起管理异步操作的执行。异步上下文是一种保存与异步操作相关的上下文信息的机制，包括线程 ID、SynchronizationContext 对象等。异步操作在等待其他操作完成时可能会保存当前上下文，以便可以在异步操作完成时恢复它。当前上下文与异步操作的执行是密切相关的，异步操作必须在正确的上下文中执行才能正常工作</p><h2 id=理解>理解<a hidden class=anchor aria-hidden=true href=#理解>¶</a></h2><ul><li><p>如果使用的是 UI 线程，那么就是 UI 上下文</p></li><li><p>如果使用的是 ASP.NET 请求响应，那么这就是 ASP.NET 请求上下文</p></li><li><p>其余情况都是线程池上下文</p></li></ul><p>当我们等待 <code>Task</code> 时，当等待决定暂停方法执行时，会捕获请求当前上下文。一旦方法准备好恢复执行，应用程序将从线程池中获取线程，将其分配给上下文，并恢复执行</p><p>在 ASP.NET Core 应用程序中没有<code> SynchronizationContext</code>。ASP.NET Core 避免捕获上下文并排队，它所做的只是从线程池中获取线程并将其分配给请求，因此，应用程序要做的后台工作要少得多</p><h2 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>¶</a></h2><ol><li></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=c1>// WinForms 示例程序(同样原理用于 WPF 程序).</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>async</span> <span class=k>void</span> <span class=n>DownloadFileButton_Click</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>EventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 因为我们使用了异步关键字 awiat，这个 UI 线程不会被文件下载阻止</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=n>DownloadFileAsync</span><span class=p>(</span><span class=n>fileNameTextBox</span><span class=p>.</span><span class=n>Text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 由于我们恢复了 UI 上下文，可以直接调用 UI 元素</span>
</span></span><span class=line><span class=cl>  <span class=n>resultTextBox</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=s>&#34;File downloaded!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=2><li></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=k>void</span> <span class=n>button</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;main1 thread {Thread.CurrentThread.ManagedThreadId}&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=n>TestConfigureAwait</span><span class=p>().</span><span class=n>Wait</span><span class=p>();</span>  
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;main2 thread: {Thread.CurrentThread.ManagedThreadId}&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=k>async</span> <span class=n>Task</span> <span class=n>TestConfigureAwait</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>Task</span><span class=p>.</span><span class=n>Run</span><span class=p>(()</span> <span class=p>=&gt;</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>Thread</span><span class=p>.</span><span class=n>Sleep</span><span class=p>(</span><span class=m>6000</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;task thread: {Thread.CurrentThread.ManagedThreadId}&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=p>}).</span><span class=n>ConfigureAwait</span><span class=p>(</span><span class=k>false</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>     
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;testConfigureAwait thread: {Thread.CurrentThread.ManagedThreadId}&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这个示例中，是一个 UI 上下文内容，和使用了 <code>ConfigureAwait(false)</code> 来解决死锁问题</p><h1 id=异常捕获>异常捕获<a hidden class=anchor aria-hidden=true href=#异常捕获>¶</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>public</span> <span class=k>static</span> <span class=k>void</span> <span class=n>Test</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>try</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>result</span> <span class=p>=</span> <span class=n>SomeAsyncCode</span><span class=p>().</span><span class=n>Result</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(</span><span class=n>ArgumentException</span> <span class=n>aex</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>        
</span></span><span class=line><span class=cl>	    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Caught ArgumentException: {aex.Message}&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>static</span> <span class=k>async</span> <span class=n>Task</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>SomeAsyncCode</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>Task</span><span class=p>.</span><span class=n>Delay</span><span class=p>(</span><span class=m>10</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>ArgumentException</span><span class=p>(</span><span class=s>&#34;Oh noes!&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这个示例中我们尝试使用 <code>try-catch</code> 来捕捉异常，我们执行 <code>SomeAsyncCode()</code>，获取到它的 <code>Result</code> 属性。可以发现我们并没有进入到 <code>catch</code> 块。</p><p>这是因为，如果没有等待关键字，任务会吞噬异常。此外，不再有继续，操作也没有经过验证。如果继续执行此操作，将获得一个异常，但这将是映射异常，而不是我们从异步方法中抛出的异常</p><pre tabindex=0><code class=language-log data-lang=log>--- EXCEPTION #1/2 [ArgumentException]
</code></pre><p>在发生 ArgumentException 时，使用其他关键字尝试解决</p><p>在此示例，我们不能用 <code>await</code> 关键字来等待结果，我们使用 <code>SomeAsyncCode().GetAwaiter().GetResult()</code> 来捕捉，运行后结果正确，成功进入 <code>catch</code> 块</p><p>也可以使用 <a href=https://code-maze.com/global-error-handling-aspnetcore/>Global Error Handling</a> 技术来解决或跟踪异常</p><h1 id=控制台程序>控制台程序<a hidden class=anchor aria-hidden=true href=#控制台程序>¶</a></h1><p>在 C# 7.1 之前其实是不能对控制台程序对主入口 <code>Main</code> 函数标记为 <code>async</code></p><h2 id=原因>原因<a hidden class=anchor aria-hidden=true href=#原因>¶</a></h2><p>如果 <code>await</code> 看到可等待项尚未完成，那么它会异步发挥作用。它告诉 awaitable 在方法完成后运行剩余部分，然后从异步方法返回。当将方法的剩余部分传递给 <code>await</code> 时，awaiter 还将捕获当前上下文</p><p>异步方法将在完成之前返回给其调用者。这在 UI 应用程序（方法仅返回 UI 事件循环）和 ASP.NET 应用程序（该方法从线程返回，但使请求保持保留状态）中完美工作</p><p>对于控制台程序来说效果不太好：<code>Main</code> 函数返回到操作系统，因此程序退出</p><h2 id=解决>解决<a hidden class=anchor aria-hidden=true href=#解决>¶</a></h2><p>控制台程序没有很大的必要使用异步，但为简单的一些操作演示，也是能解决的</p><p>让主线程强制等待异步完成，如以下示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>(</span><span class=kt>string</span><span class=p>[]</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>MainAsync</span><span class=p>(</span><span class=n>args</span><span class=p>).</span><span class=n>GetAwaiter</span><span class=p>().</span><span class=n>GetResult</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=c1>// or MainAsync(args).Wait()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>async</span> <span class=n>Task</span> <span class=n>MainAsync</span><span class=p>(</span><span class=kt>string</span><span class=p>[]</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Bootstrapper</span> <span class=n>bs</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Bootstrapper</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>var</span> <span class=n>list</span> <span class=p>=</span> <span class=k>await</span> <span class=n>bs</span><span class=p>.</span><span class=n>GetList</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>主要就是 <code>GetAwaiter</code> 方法和 <code>GetResult</code> 方法，前者是获取到有 <code>Task</code> 标记的异步程序，后者是等待此有 <code>Task</code> 标记的异步程序结束</p><p>也可以直接使用 <code>MainAsync(args).Wait()</code>，<code>Wait</code> 方法与上面类似，但上面的两个方法会避免一些 <code>AggregateException</code> 包装错误</p><h1 id=总结-1>总结<a hidden class=anchor aria-hidden=true href=#总结-1>¶</a></h1><p>以上内容为搜罗实验整理，如有错误欢迎留言指正交流，如有内容变动会及时更新</p><p>更多参考：</p><table><thead><tr><th style=text-align:center><strong>Old</strong></th><th style=text-align:center><strong>New</strong></th><th style=text-align:center><strong>Description</strong></th></tr></thead><tbody><tr><td style=text-align:center>task.Wait</td><td style=text-align:center>await task</td><td style=text-align:center>Wait/await for a task to complete</td></tr><tr><td style=text-align:center>task.Result</td><td style=text-align:center>await task</td><td style=text-align:center>Get the result of a completed task</td></tr><tr><td style=text-align:center>Task.WaitAny</td><td style=text-align:center>await Task.WhenAny</td><td style=text-align:center>Wait/await for one of a collection of tasks to complete</td></tr><tr><td style=text-align:center>Task.WaitAll</td><td style=text-align:center>await Task.WhenAll</td><td style=text-align:center>Wait/await for every one of a collection of tasks to complete</td></tr><tr><td style=text-align:center>Thread.Sleep</td><td style=text-align:center>await Task.Delay</td><td style=text-align:center>Wait/await for a period of time</td></tr><tr><td style=text-align:center>Task constructor</td><td style=text-align:center>Task.Run or TaskFactory.StartNew</td><td style=text-align:center>Create a code-based task</td></tr></tbody></table><ul><li><a href=https://stackoverflow.com/questions/9343594/how-to-call-asynchronous-method-from-synchronous-method-in-c>How to call asynchronous method from synchronous method in C#?</a></li><li><a href=https://blog.stephencleary.com/2014/04/a-tour-of-task-part-0-overview.html>A Tour of Task</a></li><li><a href=https://blog.stephencleary.com/2012/02/async-and-await.html#comments>Async and Await</a></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter1/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Unity 性能优化 Chapter1</span></a>
<a class=next href=https://brealinhub.com/posts/%E7%BA%BF%E7%A8%8B/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>线程</span></a></nav></footer><div class=comments-separator></div><script src=https://utteranc.es/client.js repo=Brealin233/CommentReop issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://brealinhub.com/>brealinblog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js></script>
<script>const images=Array.from(document.querySelectorAll(".post-content img"));images.forEach(e=>{mediumZoom(e,{margin:0,scrollOffset:10,container:null,template:null,background:"rgba(0, 0, 0, 0.8)"})})</script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>