<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unity 性能优化 Chapter3 | brealinblog</title><meta name=keywords content="Unity,性能优化"><meta name=description content="性能优化问题的本质 慢与快的问题
前提
稳定性：不能因优化造成稳定性变差
兼容性：不能因优化导致兼容性变差
性价比：优化要有度，考虑成本与复杂度
性能优化的流程 发现问题（什么平台、什么操作系统、什么情况下出现问题，一般问题还是特例问题等） 定位问题（什么地方造成的性能问题，我们要用什么工具、什么方法确定瓶颈） 研究问题（确定用什么方案处理这个问题，要考虑性能优化的前提） 解决问题（按问题研究的结论去实际处理，并验证处理结果与预期的一致性） 影响性能的问题 CPU 通常，CPU 渲染时间的最大贡献者是向 GPU 发送渲染命令的成本。渲染命令包括绘制调用（绘制几何形状的命令），以及在绘制几何形状之前更改 GPU 上设置的命令
减少 Unity 渲染的对象数量 考虑减少场景中对象的总数，例如：使用 skybox 来创建遥远几何的效果 执行更严格的剔除，以便 Unity 绘制更少的对象。考虑使用遮挡剔除来防止 Unity 绘制隐藏在其他物体后面的物体，减少相机的远夹平面，以便更远的物体落在其果实之外，或者，对于更细粒度的方法，将物体放入单独的层，并使用 Camera.layerCullDistances 设置每层剔除距离 减少 Unity 渲染每个对象的次数 在适当的情况下，使用 light mapping 来烘焙（预计算）照明和阴影。这增加了构建时间、运行时内存使用和存储空间，但可以提高运行时性能 如果应用程序使用 Forward rendering，请减少影响对象的每像素实时灯光的数量 实时阴影可能是非常资源密集型，因此请谨慎而高效地使用它们 如果应用程序使用反射探针，请确保您优化其使用 GPU 填充率的限制 GPU 试图每帧绘制的像素比它所能处理的要多，如果是这种情况，请考虑以下选项：
识别并减少应用程序中的透支。透支最常见的贡献者是重叠的透明元素，如 UI、粒子和 Sprite，在 Unity 编辑器中，使用 Overdraw Draw模式 来识别有问题的区域 降低片段着色器的执行成本 如果您使用的是 Unity 的内置着色器，请从 Mobile 或 Unlit 类别中选择一个。它们也适用于非移动平台，但它们是更复杂的着色器的简化和近似版本 动态分辨率是一个 Unity 功能，允许您动态缩放单个渲染目标 内存带宽的限制 GPU 正在尝试向其专用内存读取和写入比它在帧中可以处理的更多数据。这通常意味着有太多的纹理，或者纹理太大。如果是这种情况，请考虑以下选项："><meta name=author content="Me"><link rel=canonical href=https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter3/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c90ce37b18981f885b1cc08faf9cc8c453a1933d0b9e9145780290f37caa9d8f.css integrity="sha256-yQzjexiYH4hbHMCPr5zIxFOhkz0LnpFFeAKQ83yqnY8=" rel="preload stylesheet" as=style><link rel=icon href=https://brealinhub.com/favicon.ico><link rel=apple-touch-icon href=https://brealinhub.com/apple-touch-icon.png><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-9GSM0N8QP8","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Unity 性能优化 Chapter3 | brealinblog"><meta name=twitter:description content="性能优化问题的本质 慢与快的问题
前提
稳定性：不能因优化造成稳定性变差
兼容性：不能因优化导致兼容性变差
性价比：优化要有度，考虑成本与复杂度
性能优化的流程 发现问题（什么平台、什么操作系统、什么情况下出现问题，一般问题还是特例问题等） 定位问题（什么地方造成的性能问题，我们要用什么工具、什么方法确定瓶颈） 研究问题（确定用什么方案处理这个问题，要考虑性能优化的前提） 解决问题（按问题研究的结论去实际处理，并验证处理结果与预期的一致性） 影响性能的问题 CPU 通常，CPU 渲染时间的最大贡献者是向 GPU 发送渲染命令的成本。渲染命令包括绘制调用（绘制几何形状的命令），以及在绘制几何形状之前更改 GPU 上设置的命令
减少 Unity 渲染的对象数量 考虑减少场景中对象的总数，例如：使用 skybox 来创建遥远几何的效果 执行更严格的剔除，以便 Unity 绘制更少的对象。考虑使用遮挡剔除来防止 Unity 绘制隐藏在其他物体后面的物体，减少相机的远夹平面，以便更远的物体落在其果实之外，或者，对于更细粒度的方法，将物体放入单独的层，并使用 Camera.layerCullDistances 设置每层剔除距离 减少 Unity 渲染每个对象的次数 在适当的情况下，使用 light mapping 来烘焙（预计算）照明和阴影。这增加了构建时间、运行时内存使用和存储空间，但可以提高运行时性能 如果应用程序使用 Forward rendering，请减少影响对象的每像素实时灯光的数量 实时阴影可能是非常资源密集型，因此请谨慎而高效地使用它们 如果应用程序使用反射探针，请确保您优化其使用 GPU 填充率的限制 GPU 试图每帧绘制的像素比它所能处理的要多，如果是这种情况，请考虑以下选项：
识别并减少应用程序中的透支。透支最常见的贡献者是重叠的透明元素，如 UI、粒子和 Sprite，在 Unity 编辑器中，使用 Overdraw Draw模式 来识别有问题的区域 降低片段着色器的执行成本 如果您使用的是 Unity 的内置着色器，请从 Mobile 或 Unlit 类别中选择一个。它们也适用于非移动平台，但它们是更复杂的着色器的简化和近似版本 动态分辨率是一个 Unity 功能，允许您动态缩放单个渲染目标 内存带宽的限制 GPU 正在尝试向其专用内存读取和写入比它在帧中可以处理的更多数据。这通常意味着有太多的纹理，或者纹理太大。如果是这种情况，请考虑以下选项："><meta property="og:title" content="Unity 性能优化 Chapter3 | brealinblog"><meta property="og:description" content="性能优化问题的本质 慢与快的问题
前提
稳定性：不能因优化造成稳定性变差
兼容性：不能因优化导致兼容性变差
性价比：优化要有度，考虑成本与复杂度
性能优化的流程 发现问题（什么平台、什么操作系统、什么情况下出现问题，一般问题还是特例问题等） 定位问题（什么地方造成的性能问题，我们要用什么工具、什么方法确定瓶颈） 研究问题（确定用什么方案处理这个问题，要考虑性能优化的前提） 解决问题（按问题研究的结论去实际处理，并验证处理结果与预期的一致性） 影响性能的问题 CPU 通常，CPU 渲染时间的最大贡献者是向 GPU 发送渲染命令的成本。渲染命令包括绘制调用（绘制几何形状的命令），以及在绘制几何形状之前更改 GPU 上设置的命令
减少 Unity 渲染的对象数量 考虑减少场景中对象的总数，例如：使用 skybox 来创建遥远几何的效果 执行更严格的剔除，以便 Unity 绘制更少的对象。考虑使用遮挡剔除来防止 Unity 绘制隐藏在其他物体后面的物体，减少相机的远夹平面，以便更远的物体落在其果实之外，或者，对于更细粒度的方法，将物体放入单独的层，并使用 Camera.layerCullDistances 设置每层剔除距离 减少 Unity 渲染每个对象的次数 在适当的情况下，使用 light mapping 来烘焙（预计算）照明和阴影。这增加了构建时间、运行时内存使用和存储空间，但可以提高运行时性能 如果应用程序使用 Forward rendering，请减少影响对象的每像素实时灯光的数量 实时阴影可能是非常资源密集型，因此请谨慎而高效地使用它们 如果应用程序使用反射探针，请确保您优化其使用 GPU 填充率的限制 GPU 试图每帧绘制的像素比它所能处理的要多，如果是这种情况，请考虑以下选项：
识别并减少应用程序中的透支。透支最常见的贡献者是重叠的透明元素，如 UI、粒子和 Sprite，在 Unity 编辑器中，使用 Overdraw Draw模式 来识别有问题的区域 降低片段着色器的执行成本 如果您使用的是 Unity 的内置着色器，请从 Mobile 或 Unlit 类别中选择一个。它们也适用于非移动平台，但它们是更复杂的着色器的简化和近似版本 动态分辨率是一个 Unity 功能，允许您动态缩放单个渲染目标 内存带宽的限制 GPU 正在尝试向其专用内存读取和写入比它在帧中可以处理的更多数据。这通常意味着有太多的纹理，或者纹理太大。如果是这种情况，请考虑以下选项："><meta property="og:type" content="article"><meta property="og:url" content="https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter3/"><meta property="og:image" content="https://brealinhub.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-07T14:00:01+00:00"><meta property="article:modified_time" content="2023-04-07T14:00:01+00:00"><meta property="og:site_name" content="brealinblog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://brealinhub.com/posts/"},{"@type":"ListItem","position":2,"name":"Unity 性能优化 Chapter3","item":"https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unity 性能优化 Chapter3 | brealinblog","name":"Unity 性能优化 Chapter3","description":"性能优化问题的本质 慢与快的问题\n前提\n稳定性：不能因优化造成稳定性变差\n兼容性：不能因优化导致兼容性变差\n性价比：优化要有度，考虑成本与复杂度\n性能优化的流程 发现问题（什么平台、什么操作系统、什么情况下出现问题，一般问题还是特例问题等） 定位问题（什么地方造成的性能问题，我们要用什么工具、什么方法确定瓶颈） 研究问题（确定用什么方案处理这个问题，要考虑性能优化的前提） 解决问题（按问题研究的结论去实际处理，并验证处理结果与预期的一致性） 影响性能的问题 CPU 通常，CPU 渲染时间的最大贡献者是向 GPU 发送渲染命令的成本。渲染命令包括绘制调用（绘制几何形状的命令），以及在绘制几何形状之前更改 GPU 上设置的命令\n减少 Unity 渲染的对象数量 考虑减少场景中对象的总数，例如：使用 skybox 来创建遥远几何的效果 执行更严格的剔除，以便 Unity 绘制更少的对象。考虑使用遮挡剔除来防止 Unity 绘制隐藏在其他物体后面的物体，减少相机的远夹平面，以便更远的物体落在其果实之外，或者，对于更细粒度的方法，将物体放入单独的层，并使用 Camera.layerCullDistances 设置每层剔除距离 减少 Unity 渲染每个对象的次数 在适当的情况下，使用 light mapping 来烘焙（预计算）照明和阴影。这增加了构建时间、运行时内存使用和存储空间，但可以提高运行时性能 如果应用程序使用 Forward rendering，请减少影响对象的每像素实时灯光的数量 实时阴影可能是非常资源密集型，因此请谨慎而高效地使用它们 如果应用程序使用反射探针，请确保您优化其使用 GPU 填充率的限制 GPU 试图每帧绘制的像素比它所能处理的要多，如果是这种情况，请考虑以下选项：\n识别并减少应用程序中的透支。透支最常见的贡献者是重叠的透明元素，如 UI、粒子和 Sprite，在 Unity 编辑器中，使用 Overdraw Draw模式 来识别有问题的区域 降低片段着色器的执行成本 如果您使用的是 Unity 的内置着色器，请从 Mobile 或 Unlit 类别中选择一个。它们也适用于非移动平台，但它们是更复杂的着色器的简化和近似版本 动态分辨率是一个 Unity 功能，允许您动态缩放单个渲染目标 内存带宽的限制 GPU 正在尝试向其专用内存读取和写入比它在帧中可以处理的更多数据。这通常意味着有太多的纹理，或者纹理太大。如果是这种情况，请考虑以下选项：","keywords":["Unity","性能优化"],"wordCount":"247","inLanguage":"en","datePublished":"2023-04-07T14:00:01Z","dateModified":"2023-04-07T14:00:01Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter3/"},"publisher":{"@type":"Organization","name":"brealinblog","logo":{"@type":"ImageObject","url":"https://brealinhub.com/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://brealinhub.com/ accesskey=h title="brealinblog (Alt + H)">brealinblog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://brealinhub.com/tags/ title=Tags>Tags</a></li><li><a href=https://brealinhub.com/archives/ title=Archive>Archive</a></li><li><a href=https://brealinhub.com/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://brealinhub.com/ title=@brealin class=active target=_blank>@brealin<span class=external-link><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://brealinhub.com/>Home</a>&nbsp;»&nbsp;<a href=https://brealinhub.com/posts/>Posts</a></div><h1 class=post-title>Unity 性能优化 Chapter3</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>April 7, 2023</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://brealinhub.com/tags/unity/>Unity</a><a href=https://brealinhub.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>性能优化</a></span></span></div></header><div class="toc side right"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e9%97%ae%e9%a2%98%e7%9a%84%e6%9c%ac%e8%b4%a8 aria-label=性能优化问题的本质>性能优化问题的本质</a></li><li><a href=#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=性能优化的流程>性能优化的流程</a></li><li><a href=#%e5%bd%b1%e5%93%8d%e6%80%a7%e8%83%bd%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=影响性能的问题>影响性能的问题</a><ul><li><a href=#cpu aria-label=CPU>CPU</a><ul><li><a href=#%e5%87%8f%e5%b0%91-unity-%e6%b8%b2%e6%9f%93%e7%9a%84%e5%af%b9%e8%b1%a1%e6%95%b0%e9%87%8f aria-label="减少 Unity 渲染的对象数量">减少 Unity 渲染的对象数量</a></li><li><a href=#%e5%87%8f%e5%b0%91-unity-%e6%b8%b2%e6%9f%93%e6%af%8f%e4%b8%aa%e5%af%b9%e8%b1%a1%e7%9a%84%e6%ac%a1%e6%95%b0 aria-label="减少 Unity 渲染每个对象的次数">减少 Unity 渲染每个对象的次数</a></li></ul></li><li><a href=#gpu aria-label=GPU>GPU</a><ul><li><a href=#%e5%a1%ab%e5%85%85%e7%8e%87%e7%9a%84%e9%99%90%e5%88%b6 aria-label=填充率的限制>填充率的限制</a></li><li><a href=#%e5%86%85%e5%ad%98%e5%b8%a6%e5%ae%bd%e7%9a%84%e9%99%90%e5%88%b6 aria-label=内存带宽的限制>内存带宽的限制</a></li><li><a href=#%e9%a1%b6%e7%82%b9%e5%a4%84%e7%90%86%e7%9a%84%e9%99%90%e5%88%b6 aria-label=顶点处理的限制>顶点处理的限制</a></li></ul></li><li><a href=#%e9%99%8d%e4%bd%8e%e6%b8%b2%e6%9f%93%e9%a2%91%e7%8e%87 aria-label=降低渲染频率>降低渲染频率</a></li><li><a href=#%e9%9a%90%e8%97%8f%e7%9a%84%e5%87%a0%e7%b1%bb%e5%b0%8f%e9%97%ae%e9%a2%98 aria-label=隐藏的几类小问题>隐藏的几类小问题</a></li></ul></li><li><a href=#%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%8f%af%e8%83%bd%e7%9a%84%e6%83%85%e5%86%b5 aria-label=性能问题可能的情况>性能问题可能的情况</a></li><li><a href=#%e7%bb%8f%e5%b8%b8%e7%94%a8%e7%9a%84%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af aria-label=经常用的优化思路>经常用的优化思路</a><ul><li><a href=#aos-and-soa aria-label="AoS and SoA">AoS and SoA</a><ul><li><a href=#aos aria-label=AoS>AoS</a></li><li><a href=#soa aria-label=SoA>SoA</a></li><li><a href=#%e5%b7%ae%e5%bc%82 aria-label=差异>差异</a></li></ul></li><li><a href=#structureofarraysgenerator aria-label=StructureOfArraysGenerator>StructureOfArraysGenerator</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><h2 id=性能优化问题的本质>性能优化问题的本质<a hidden class=anchor aria-hidden=true href=#性能优化问题的本质>¶</a></h2><ul><li><p>慢与快的问题</p></li><li><p>前提</p><ul><li><p>稳定性：不能因优化造成稳定性变差</p></li><li><p>兼容性：不能因优化导致兼容性变差</p></li><li><p>性价比：优化要有度，考虑成本与复杂度</p></li></ul></li></ul><h2 id=性能优化的流程>性能优化的流程<a hidden class=anchor aria-hidden=true href=#性能优化的流程>¶</a></h2><ol><li>发现问题（什么平台、什么操作系统、什么情况下出现问题，一般问题还是特例问题等）</li><li>定位问题（什么地方造成的性能问题，我们要用什么工具、什么方法确定瓶颈）</li><li>研究问题（确定用什么方案处理这个问题，要考虑性能优化的前提）</li><li>解决问题（按问题研究的结论去实际处理，并验证处理结果与预期的一致性）</li></ol><h2 id=影响性能的问题>影响性能的问题<a hidden class=anchor aria-hidden=true href=#影响性能的问题>¶</a></h2><h3 id=cpu>CPU<a hidden class=anchor aria-hidden=true href=#cpu>¶</a></h3><p>通常，CPU 渲染时间的最大贡献者是向 GPU 发送渲染命令的成本。渲染命令包括绘制调用（绘制几何形状的命令），以及在绘制几何形状之前更改 GPU 上设置的命令</p><h4 id=减少-unity-渲染的对象数量>减少 Unity 渲染的对象数量<a hidden class=anchor aria-hidden=true href=#减少-unity-渲染的对象数量>¶</a></h4><ul><li>考虑减少场景中对象的总数，例如：使用 skybox 来创建遥远几何的效果</li><li>执行更严格的剔除，以便 Unity 绘制更少的对象。考虑使用遮挡剔除来防止 Unity 绘制隐藏在其他物体后面的物体，减少相机的远夹平面，以便更远的物体落在其果实之外，或者，对于更细粒度的方法，将物体放入单独的层，并使用 <a href=https://docs.unity3d.com/cn/2021.3/ScriptReference/Camera-layerCullDistances.html>Camera.layerCullDistances</a> 设置每层剔除距离</li></ul><h4 id=减少-unity-渲染每个对象的次数>减少 Unity 渲染每个对象的次数<a hidden class=anchor aria-hidden=true href=#减少-unity-渲染每个对象的次数>¶</a></h4><ul><li>在适当的情况下，使用 <a href=https://docs.unity3d.com/cn/2021.3/Manual/Lightmappers.html>light mapping</a> 来烘焙（预计算）照明和阴影。这增加了构建时间、运行时内存使用和存储空间，但可以提高运行时性能</li><li>如果应用程序使用 Forward rendering，请减少影响对象的每像素实时灯光的数量</li><li>实时阴影可能是非常资源密集型，因此请谨慎而高效地使用它们</li><li>如果应用程序使用反射探针，请确保您优化其使用</li></ul><h3 id=gpu>GPU<a hidden class=anchor aria-hidden=true href=#gpu>¶</a></h3><h4 id=填充率的限制>填充率的限制<a hidden class=anchor aria-hidden=true href=#填充率的限制>¶</a></h4><p>GPU 试图每帧绘制的像素比它所能处理的要多，如果是这种情况，请考虑以下选项：</p><ul><li>识别并减少应用程序中的透支。透支最常见的贡献者是重叠的透明元素，如 UI、粒子和 Sprite，在 Unity 编辑器中，使用 <a href=https://docs.unity3d.com/cn/2021.3/Manual/ViewModes.html>Overdraw Draw模式</a> 来识别有问题的区域</li><li>降低片段着色器的执行成本</li><li>如果您使用的是 Unity 的内置着色器，请从 Mobile 或 Unlit 类别中选择一个。它们也适用于非移动平台，但它们是更复杂的着色器的简化和近似版本</li><li>动态分辨率是一个 Unity 功能，允许您动态缩放单个渲染目标</li></ul><h4 id=内存带宽的限制>内存带宽的限制<a hidden class=anchor aria-hidden=true href=#内存带宽的限制>¶</a></h4><p>GPU 正在尝试向其专用内存读取和写入比它在帧中可以处理的更多数据。这通常意味着有太多的纹理，或者纹理太大。如果是这种情况，请考虑以下选项：</p><ul><li>为与相机距离在运行时变化的纹理启用 mipmap（例如，3D场景中使用的大多数纹理），这增加了这些纹理的内存使用量和存储空间，但可以提高运行时 GPU 的性能</li><li>使用合适的压缩格式来减小内存中纹理的大小。这可能会导致更快的加载时间、更小的内存占用和更高的 GPU 渲染性能。压缩纹理仅使用未压缩纹理所需的内存带宽的一小部分</li></ul><h4 id=顶点处理的限制>顶点处理的限制<a hidden class=anchor aria-hidden=true href=#顶点处理的限制>¶</a></h4><p>这意味着GPU正在尝试处理比它在帧中处理的更多的顶点。如果是这种情况，请考虑以下选项：</p><ul><li>降低顶点着色器的执行成本</li><li>优化您的几何形状：不要使用不必要的三角形，并尽量保持紫外线映射接缝和硬边（加倍顶点）的数量</li><li>使用 Level of Detail 系统</li></ul><h3 id=降低渲染频率>降低渲染频率<a hidden class=anchor aria-hidden=true href=#降低渲染频率>¶</a></h3><p>有时，降低渲染帧速率可能会使应用程序受益，这不会降低渲染单个帧的 CPU 或 GPU 成本，但它减少了 Unity 这样做的频率，而不会影响其他操作（如脚本执行）的频率</p><p>可以降低应用程序部分或整个应用程序的渲染帧速率。降低渲染帧速率，以防止不必要的电力使用，延长电池寿命，并防止设备温度上升到 CPU 频率可能受到限制的程度。这在手持设备上特别有用</p><h3 id=隐藏的几类小问题>隐藏的几类小问题<a hidden class=anchor aria-hidden=true href=#隐藏的几类小问题>¶</a></h3><ul><li>功耗比</li><li>填充率</li><li>发热量</li></ul><h2 id=性能问题可能的情况>性能问题可能的情况<a hidden class=anchor aria-hidden=true href=#性能问题可能的情况>¶</a></h2><ul><li>瓶颈可能性按由高到低的顺序排列（UP 经验总结）<ul><li>CPU 利用率</li><li>带宽利用率</li><li>CPU / GPU 强制同步</li><li>片元着色器指令</li><li>几何图形到 CPU 到 GPU 的传输</li><li>纹理 CPU 到 GPU 的传输</li><li>顶点着色器指令</li><li>几何图形复杂性</li></ul></li></ul><h2 id=经常用的优化思路>经常用的优化思路<a hidden class=anchor aria-hidden=true href=#经常用的优化思路>¶</a></h2><ul><li>升维与降维</li></ul><p>升维：优化性能，但算法不易理解
降维：算法容易理解，但性能优化差</p><ul><li>维度转换，如空间与时间、量纲转换</li></ul><p>{%note primary%}</p><h3 id=aos-and-soa>AoS and SoA<a hidden class=anchor aria-hidden=true href=#aos-and-soa>¶</a></h3><p>结构数组（AoS），数组结构（SoA）或数组结构数组（AoSoA）是排列内存中记录序列的对比方法，涉及交错，并且对 <a href=https://en.wikipedia.org/wiki/Single_instruction,_multiple_data>SIMD</a> 和 SIMT 编程有关</p><p>标准 C# 数组是 AoS，但 SoA 的结构适用于使用 CPU 缓存，CPU 缓存比主内存快，以及 SIMD 的超快速并行处理</p><h4 id=aos>AoS<a hidden class=anchor aria-hidden=true href=#aos>¶</a></h4><p>面向对象思想，不同字段的数据在其中交错，这通常更直观，并由大多数编程语言直接支持</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>-----------------------------------------------------------------------------
</span></span><span class=line><span class=cl>| double | int | char | *pad* | double | int | char | *pad* | double | int | char |
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------
</span></span></code></pre></div><h4 id=soa>SoA<a hidden class=anchor aria-hidden=true href=#soa>¶</a></h4><p>面向数据思想，将记录的元素（或 C 编程语言中的“结构”）分离成每个字段一个并行数组。在大多数指令集架构中，使用打包的 SIMD 指令更容易操作，因为单个 SIMD 寄存器可以加载同质数据，可能由广泛的内部数据路径（例如128位）传输</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>-----------------------------------------------------------------------------
</span></span><span class=line><span class=cl>| double | double | double | *pad* | int | int | int | *pad* | char | char | char |
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------
</span></span></code></pre></div><p>如果只需要记录的特定部分，则只需要迭代这些部分，允许将更多数据放入单个缓存行中。缺点是遍历数据时需要更多的缓存方式，以及低效的索引寻址</p><h4 id=差异>差异<a hidden class=anchor aria-hidden=true href=#差异>¶</a></h4><ol><li><p>由于每个对象都保存在一起，因此 AoS 对程序员来说更容易阅读</p></li><li><p>如果结构的所有成员一起访问，AoS 可能会有更好的缓存位置</p></li><li><p>SoA 可能更有效率，因为将相同的数据类型组合在一起有时会暴露矢量化</p></li><li><p>在许多情况下，SoA 使用的内存较少，因为填充仅在数组之间，而不是在每个结构之间</p></li></ol><h3 id=structureofarraysgenerator>StructureOfArraysGenerator<a hidden class=anchor aria-hidden=true href=#structureofarraysgenerator>¶</a></h3><p>Structure of arrays source generator 插件制造 CPU 缓存和 SIMD 友好的数据结构制造高性能代码用于 .NET 和 Unity 平台</p><p><a href=https://user-images.githubusercontent.com/46207/214814782-fd341e09-731a-4e2f-ba53-ef789a19160e.png><img loading=lazy src=https://user-images.githubusercontent.com/46207/214814782-fd341e09-731a-4e2f-ba53-ef789a19160e.png alt=principle></a></p><p>点击<a href=(https://github.com/Cysharp/StructureOfArraysGenerator)><strong>链接</strong></a>以了解更多</p><p>{%endnote%}</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>¶</a></h2><ul><li><p><a href=https://learn.unity.com/tutorial/fixing-performance-problems-2019-3-1#>Fixing Performance Problems - 2019.3</a></p></li><li><p><a href=https://docs.unity3d.com/cn/2021.3/Manual/OptimizingGraphicsPerformance.html>Graphics performance fundamentals</a></p></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://brealinhub.com/posts/%E4%B8%80%E4%BA%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>一些自定义配置</span></a>
<a class=next href=https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter2/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Unity 性能优化 Chapter2</span></a></nav></footer><div class=comments-separator></div><script src=https://utteranc.es/client.js repo=Brealin233/CommentReop issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://brealinhub.com/>brealinblog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js></script>
<script>const images=Array.from(document.querySelectorAll(".post-content img"));images.forEach(e=>{mediumZoom(e,{margin:0,scrollOffset:10,container:null,template:null,background:"rgba(0, 0, 0, 0.8)"})})</script><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>